{"version":3,"file":"tiles.js","sources":["../../../../src/tile-layout/table-utils/tiles.ts"],"sourcesContent":["import { GridConfig, TilePositionInfo } from '../model';\nimport { newTable } from './table';\n\nexport const positionedTilesMaxRows = <T>(\n  positionedTiles: TilePositionInfo<T>[]\n) => {\n  //calculate the max row\n  return positionedTiles.reduce<number>((memo, tile) => {\n    const maxTileRow = tile.row + tile.rowSpan;\n    return memo > maxTileRow ? memo : maxTileRow;\n  }, 0);\n};\n\n/**\n * Check if the elements are overlapping in the table\n *\n * @param positionedTiles\n */\nexport const checkOverlap = <T>(\n  positionedTiles: TilePositionInfo<T>[],\n  { columns }: GridConfig\n) => {\n  //calculate the max row\n  const maxRows = positionedTilesMaxRows(positionedTiles);\n\n  //create a new temporary table to support the overlap check\n  //the rows need to be filled with null  and then mapped,\n  //otherwise each row will be identical\n  const checkTable = newTable(maxRows, columns, false);\n\n  const overlaps = positionedTiles.find(tile => {\n    for (let col = tile.col; col <= tile.col + tile.colSpan - 1; col++) {\n      for (let row = tile.row; row <= tile.row + tile.rowSpan - 1; row++) {\n        console.log('checktable:', {\n          tile,\n          row,\n          col,\n          outcome: checkTable[row][col],\n        });\n        if (checkTable[row][col] === true) return true;\n        checkTable[row][col] = true;\n      }\n    }\n    return false;\n  });\n  console.log('OVERLAP', overlaps);\n  return !!overlaps;\n};\n\nexport const getTileTouchPoint = <T>(\n  draggingTile: TilePositionInfo<T>,\n  targetTile: TilePositionInfo<T>,\n  absolutePosition: { x: number; y: number },\n  { elementHeight, elementWidth, activeBorderSize }: GridConfig\n) => {\n  const position = {\n    x: absolutePosition.x - targetTile.col * elementWidth,\n    y: absolutePosition.y - targetTile.row * elementHeight,\n  };\n\n  if (draggingTile.col >= targetTile.col && position.x < activeBorderSize)\n    return 'left';\n  if (\n    draggingTile.col <= targetTile.col &&\n    position.x > elementWidth * targetTile.colSpan - activeBorderSize\n  )\n    return 'right';\n  if (\n    draggingTile.row <= targetTile.row &&\n    position.y > elementHeight * targetTile.rowSpan - activeBorderSize\n  )\n    return 'bottom';\n  if (draggingTile.row >= targetTile.row && position.y < activeBorderSize)\n    return 'top';\n  if (\n    position.x > activeBorderSize &&\n    position.y < elementWidth * targetTile.colSpan - activeBorderSize &&\n    position.y > activeBorderSize &&\n    position.y < elementHeight * targetTile.rowSpan - activeBorderSize\n  )\n    return 'center';\n};\n\nexport const tileIncludes = <T>(\n  tile: TilePositionInfo<T>,\n  point: { col: number; row: number; height: number }\n) => {\n  return (\n    tile.col >= point.col &&\n    point.col < tile.col + tile.colSpan &&\n    tile.row >= point.row &&\n    point.row < tile.row + tile.rowSpan\n  );\n};\n"],"names":[],"mappings":";;IAiDa,iBAAiB,GAAG,UAC/B,YAAiC,EACjC,UAA+B,EAC/B,gBAA0C,EAC1C,EAA6D;QAA3D,aAAa,mBAAA,EAAE,YAAY,kBAAA,EAAE,gBAAgB,sBAAA;IAE/C,IAAM,QAAQ,GAAG;QACf,CAAC,EAAE,gBAAgB,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,GAAG,YAAY;QACrD,CAAC,EAAE,gBAAgB,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,GAAG,aAAa;KACvD,CAAC;IAEF,IAAI,YAAY,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,IAAI,QAAQ,CAAC,CAAC,GAAG,gBAAgB;QACrE,OAAO,MAAM,CAAC;IAChB,IACE,YAAY,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG;QAClC,QAAQ,CAAC,CAAC,GAAG,YAAY,GAAG,UAAU,CAAC,OAAO,GAAG,gBAAgB;QAEjE,OAAO,OAAO,CAAC;IACjB,IACE,YAAY,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG;QAClC,QAAQ,CAAC,CAAC,GAAG,aAAa,GAAG,UAAU,CAAC,OAAO,GAAG,gBAAgB;QAElE,OAAO,QAAQ,CAAC;IAClB,IAAI,YAAY,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,IAAI,QAAQ,CAAC,CAAC,GAAG,gBAAgB;QACrE,OAAO,KAAK,CAAC;IACf,IACE,QAAQ,CAAC,CAAC,GAAG,gBAAgB;QAC7B,QAAQ,CAAC,CAAC,GAAG,YAAY,GAAG,UAAU,CAAC,OAAO,GAAG,gBAAgB;QACjE,QAAQ,CAAC,CAAC,GAAG,gBAAgB;QAC7B,QAAQ,CAAC,CAAC,GAAG,aAAa,GAAG,UAAU,CAAC,OAAO,GAAG,gBAAgB;QAElE,OAAO,QAAQ,CAAC;AACpB;;;;"}