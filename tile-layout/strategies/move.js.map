{"version":3,"file":"move.js","sources":["../../../../src/tile-layout/strategies/move.ts"],"sourcesContent":["import { StrategyInterface, TilePositionInfo } from '../model';\nimport * as TilesTableUtils from '../table-utils/tiles-table';\nimport * as TableUtils from '../table-utils/table';\nimport * as TilesUtils from '../table-utils/tiles';\n\n/**\n * Calculates the new table configuration while the tiles are moving\n * @param offsetX\n * @param offsetY\n * @returns\n */\nconst dragMove: StrategyInterface = {\n  onDragMove: ({ offsetX, offsetY, config, state, table, canAcceptDrop }) => {\n    const { elementHeight, elementWidth, columns } = config;\n    const {\n      draggingTile,\n      dragPosition,\n      dropTargetTile,\n      droppable,\n      start,\n      tiles,\n    } = state;\n\n    if (!draggingTile || !dragPosition || !start || !tiles) return;\n\n    const x = start.col * elementWidth + offsetX + dragPosition.x;\n    const y = start.row * elementHeight + offsetY + dragPosition.y;\n\n    //find the position of the tile in the grid\n    const cell = TableUtils.pointToLocation(table, x, y, config);\n    const tsize = TableUtils.tableSize(table);\n\n    //console.log('data:', { x, y, cell, start, draggingTile });\n\n    //try to see if we're touching a hot point\n    if (cell.col <= tsize.cols && cell.row <= tsize.rows) {\n      //find the touched tile within the move\n\n      const touchedTile = table[cell.row][cell.col];\n      if (!touchedTile || touchedTile.data === draggingTile.data) return;\n\n      //get the touchpoint of the touched tile\n      const touchPoint = TilesUtils.getTileTouchPoint(\n        draggingTile,\n        touchedTile,\n        {\n          x,\n          y,\n        },\n        config\n      );\n      if (!touchPoint) return;\n\n      //console.log('HIT TOUCHPOINT', { table, tiles });\n\n      if (touchPoint === 'center') {\n        if (touchedTile === dropTargetTile)\n          return {\n            dropTargetTile,\n            droppable,\n          };\n        if (canAcceptDrop(draggingTile, touchedTile))\n          return { dropTargetTile: touchedTile, droppable: true };\n        return;\n      }\n\n      //a touchpoint has been identified\n\n      const rowDisplacement = Math.floor(dragPosition.y / elementHeight);\n      const colDisplacement = Math.floor(dragPosition.x / elementWidth);\n\n      //calculate the new dragged tile location. This depends on the touched side.\n      const newDragTileLocation = TableUtils.trimLocation(\n        table,\n        touchPoint === 'right'\n          ? {\n              col: cell.col - (draggingTile.colSpan - 1),\n              row: cell.row - rowDisplacement,\n            }\n          : touchPoint === 'left'\n          ? {\n              col: cell.col,\n              row: cell.row - rowDisplacement,\n            }\n          : touchPoint === 'top'\n          ? {\n              col: cell.col - colDisplacement,\n              row: cell.row,\n            }\n          : /*touchPoint === 'bottom'*/ {\n              col: cell.col - colDisplacement,\n              row: cell.row - (draggingTile.rowSpan - 1),\n            }\n      );\n\n      /*\n      console.log(\n        'Effective location:',\n        newDragTileLocation,\n        touchedTile,\n        touchPoint,\n        state\n      );\n      */\n\n      //identify all hover tiles (excluding ourselves)\n      const hoverTiles = TilesTableUtils.interceptTiles(\n        table,\n        newDragTileLocation.row,\n        newDragTileLocation.col,\n        draggingTile.rowSpan,\n        draggingTile.colSpan\n      ).filter(tiles => tiles.data !== draggingTile.data);\n\n      if (!hoverTiles.length) {\n        return;\n      }\n\n      //console.log('hover tiles:', hoverTiles);\n\n      //create a table with the remaining tiles\n      const otherTiles = tiles.filter(\n        tile =>\n          tile.data !== draggingTile.data &&\n          !hoverTiles.find(t => t.data === tile.data)\n      );\n      const newDraggingTile = {\n        ...draggingTile,\n        ...newDragTileLocation,\n      };\n\n      let checkTable = TableUtils.newTable(\n        tsize.rows + draggingTile.rowSpan - 1,\n        tsize.cols,\n        0\n      );\n      otherTiles.forEach(tile => {\n        checkTable = TableUtils.placeInTable(tile, 1, checkTable);\n      });\n\n      /*\n      console.log('checktable dump:');\n      checkTable.forEach(row => {\n        console.log(row.join(''));\n      });\n      */\n\n      //try to fit the dragging tile in the current location\n      if (!TableUtils.fitsInTable(newDraggingTile, checkTable)) {\n        //console.log('new drag tile does not fit');\n        return;\n      }\n      checkTable = TableUtils.placeInTable(newDraggingTile, 1, checkTable);\n\n      /*\n      console.log('checktable dump with drag tile:');\n      checkTable.forEach(row => {\n        console.log(row.join(''));\n      });\n      */\n\n      const repositionedHoverTiles: TilePositionInfo<any>[] = [];\n      if (\n        hoverTiles.find(tile => {\n          const newPosition = TableUtils.findFirstFittingPosition(\n            tile,\n            checkTable\n          );\n          //console.log('fitting', { tile, newPosition });\n          if (!newPosition) return true;\n          const repositionedTile = { ...tile, ...newPosition };\n          repositionedHoverTiles.push(repositionedTile);\n          checkTable = TableUtils.placeInTable(repositionedTile, 1, checkTable);\n          return false;\n        })\n      ) {\n        //console.log('repositioning failed');\n        return;\n      }\n\n      const reorderedTiles = [\n        ...repositionedHoverTiles,\n        ...otherTiles,\n        newDraggingTile,\n      ].sort((a, b) => a.col + a.row * columns - (b.col + b.row * columns));\n      return {\n        draggingTile: newDraggingTile,\n        tiles: reorderedTiles,\n      };\n    }\n  },\n  onDragEnd: () => undefined,\n};\n\nexport default dragMove;\n"],"names":["TableUtils.pointToLocation","TableUtils.tableSize","TilesUtils.getTileTouchPoint","TableUtils.trimLocation","TilesTableUtils.interceptTiles","TableUtils.newTable","TableUtils.placeInTable","TableUtils.fitsInTable","TableUtils.findFirstFittingPosition"],"mappings":"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"}